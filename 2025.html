<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hidden Letters – Integrated Scene</title>
  <style>
    /* Basic page and container styles */
    body {
      margin: 0;
      background: #333;
      font-family: sans-serif;
      text-align: center;
      color: #fff;
    }
    .instruction {
      margin: 15px;
      font-size: 20px;
    }
    .game-container {
      position: relative;
      width: 1200px;
      height: 800px;
      margin: 0 auto;
      border: 2px solid #444;
      overflow: hidden;
      background: #87CEEB; /* fallback sky */
    }
    /* The background canvas sits at the very back */
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
    }
    /* Each interactive object container “hosts” one object and (optionally) a hidden letter. 
       Its size is fixed so the letter can “stick out” at a set position relative to the object. */
    .interactive-container {
      position: absolute;
      width: 120px;
      height: 150px;
      /* No background so the container is transparent */
    }
    /* Object styles – these represent houses, trees, rocks, or bushes.
       They are anchored at the bottom of their container so they “sit on the ground.” */
    .object {
      position: absolute;
      bottom: 0;
      transition: transform 0.6s ease, opacity 0.6s ease;
      cursor: pointer;
    }
    /* When an object is clicked and removed, slide it to the right and fade it out */
    .object.removed {
      transform: translateX(100px);
      opacity: 0;
    }
    .object.house {
      width: 80px;
      height: 80px;
      background: #D2691E;
      border: 2px solid #8B4513;
      border-radius: 4px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
      margin: 0 auto;
    }
    .object.house::after {
      content: "";
      position: absolute;
      left: 0;
      bottom: 80px;
      width: 0;
      height: 0;
      border-left: 40px solid transparent;
      border-right: 40px solid transparent;
      border-bottom: 30px solid #B22222;
    }
    .object.tree {
      width: 60px;
      height: 100px;
      background: #8B4513;
      border-radius: 5px;
      box-shadow: 1px 1px 3px rgba(0,0,0,0.5);
      margin: 0 auto;
    }
    .object.tree::after {
      content: "";
      position: absolute;
      bottom: 70px;
      left: -20px;
      width: 100px;
      height: 60px;
      background: #228B22;
      border-radius: 50%;
    }
    .object.rock {
      width: 50px;
      height: 30px;
      background: #808080;
      border-radius: 50%;
      box-shadow: 1px 1px 3px rgba(0,0,0,0.4);
      margin: 0 auto;
    }
    .object.bush {
      width: 70px;
      height: 40px;
      background: #006400;
      border-radius: 50%;
      box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
      margin: 0 auto;
    }
    /* Letter styling – these are positioned inside the container so they “stick out” above the object.
       Their rotation (applied inline) creates variation in angle. */
    .letter {
      position: absolute;
      bottom: 60px; /* Adjust this value so the letter emerges from the top of the object */
      left: 50%;
      transform: translateX(-50%);
      font-size: 48px;
      font-weight: bold;
      color: #fff;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }
    /* Letters start partially hidden (faded) and become fully revealed when the object is clicked. */
    .letter.hidden {
      opacity: 0.3;
    }
    .letter.revealed {
      opacity: 1;
    }
    /* The solution display row */
    #solution {
      width: 1200px;
      margin: 15px auto;
      min-height: 80px;
      background: #222;
      color: #fff;
      font-size: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      letter-spacing: 8px;
    }
    .slot {
      display: inline-block;
      width: 40px;
      height: 60px;
      border-bottom: 2px solid #fff;
      margin: 0 5px;
      text-align: center;
      line-height: 60px;
    }
  </style>
</head>
<body>
  <div class="instruction">Click on the objects that hide a letter to reveal the secret message!</div>
  <div class="game-container" id="game">
    <!-- The detailed background is drawn on this canvas -->
    <canvas id="background" width="1200" height="800"></canvas>
  </div>
  <div id="solution"></div>

  <script>
    // Draw a detailed background scene on the canvas.
    function drawBackground() {
      const canvas = document.getElementById('background');
      const ctx = canvas.getContext('2d');
      const width = canvas.width, height = canvas.height;
      
      // Sky gradient: blue at the top blending to a warm tone
      const skyGrad = ctx.createLinearGradient(0, 0, 0, height);
      skyGrad.addColorStop(0, '#87CEEB');
      skyGrad.addColorStop(1, '#FFEBCD');
      ctx.fillStyle = skyGrad;
      ctx.fillRect(0, 0, width, height);
      
      // Sun with a soft glow
      const sunX = width * 0.8, sunY = height * 0.2, sunRadius = 50;
      const sunGrad = ctx.createRadialGradient(sunX, sunY, 10, sunX, sunY, sunRadius);
      sunGrad.addColorStop(0, '#FFD700');
      sunGrad.addColorStop(1, 'rgba(255,215,0,0)');
      ctx.fillStyle = sunGrad;
      ctx.beginPath();
      ctx.arc(sunX, sunY, sunRadius, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw several fluffy clouds
      function drawCloud(x, y, scale) {
        ctx.fillStyle = "rgba(255,255,255,0.8)";
        ctx.beginPath();
        ctx.arc(x, y, 20 * scale, Math.PI * 0.5, Math.PI * 1.5);
        ctx.arc(x + 25 * scale, y - 20 * scale, 20 * scale, Math.PI * 1, Math.PI * 1.85);
        ctx.arc(x + 55 * scale, y - 10 * scale, 25 * scale, Math.PI * 1.37, Math.PI * 1.91);
        ctx.arc(x + 70 * scale, y, 20 * scale, Math.PI * 1.5, Math.PI * 0.5);
        ctx.closePath();
        ctx.fill();
      }
      drawCloud(150, 100, 1);
      drawCloud(400, 80, 1.2);
      drawCloud(700, 120, 1);
      drawCloud(1000, 80, 0.8);
      
      // Mountains with snow-capped peaks
      function drawMountain(x, y, widthFactor, heightFactor, color, snowCap) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + 150 * widthFactor, y - 200 * heightFactor);
        ctx.lineTo(x + 300 * widthFactor, y);
        ctx.closePath();
        ctx.fill();
        if (snowCap) {
          ctx.fillStyle = "#FFF";
          ctx.beginPath();
          ctx.moveTo(x + 150 * widthFactor, y - 200 * heightFactor);
          ctx.lineTo(x + 130 * widthFactor, y - 150 * heightFactor);
          ctx.lineTo(x + 170 * widthFactor, y - 150 * heightFactor);
          ctx.closePath();
          ctx.fill();
        }
      }
      drawMountain(50, height * 0.8, 1, 1, "#696969", true);
      drawMountain(300, height * 0.8, 1, 1, "#808080", true);
      drawMountain(600, height * 0.8, 1, 1.2, "#505050", true);
      drawMountain(900, height * 0.8, 1, 1, "#7F7F7F", true);
      
      // Grassy ground at the bottom
      ctx.fillStyle = "#228B22";
      ctx.fillRect(0, height * 0.8, width, height * 0.2);
    }
    drawBackground();
    
    /* 
      Define interactive objects.
      – Some objects hide a letter (hasLetter: true) while others are decorative.
      – Each object has a type (house, tree, rock, or bush), a fixed horizontal (left) position (in px),
        and a vertical offset from the bottom (in px) so it appears “anchored” to the ground.
      – The letter (if any) is set to stick out above the object at a specified angle.
    */
    const secretLetters = [
      { letter: "Y", type: "house", left: 100, bottom: 150, rotation: -15 },
      { letter: "O", type: "rock",  left: 250, bottom: 140, rotation: 5 },
      { letter: "U", type: "tree",  left: 400, bottom: 120, rotation: -10 },
      { letter: "R", type: "bush",  left: 550, bottom: 130, rotation: 20 },
      { letter: "E", type: "house", left: 700, bottom: 150, rotation: -5 },
      { letter: "T", type: "rock",  left: 850, bottom: 140, rotation: 15 },
      { letter: "H", type: "tree",  left: 950, bottom: 120, rotation: -20 },
      { letter: "E", type: "bush",  left: 1100, bottom: 130, rotation: 0 },
      { letter: "B", type: "house", left: 200, bottom: 180, rotation: 10 },
      { letter: "E", type: "rock",  left: 350, bottom: 170, rotation: -10 },
      { letter: "S", type: "tree",  left: 500, bottom: 160, rotation: 5 },
      { letter: "T", type: "bush",  left: 650, bottom: 180, rotation: -15 },
      { letter: "D", type: "house", left: 800, bottom: 190, rotation: 10 },
      { letter: "A", type: "rock",  left: 950, bottom: 200, rotation: -5 },
      { letter: "D", type: "tree",  left: 1100, bottom: 210, rotation: 20 },
      { letter: "E", type: "bush",  left: 150, bottom: 120, rotation: -10 },
      { letter: "V", type: "house", left: 300, bottom: 130, rotation: 5 },
      { letter: "E", type: "rock",  left: 450, bottom: 140, rotation: -20 },
      { letter: "R", type: "tree",  left: 600, bottom: 150, rotation: 0 }
    ];
    // Mark these as containing letters (and assign their order index)
    secretLetters.forEach((item, index) => {
      item.hasLetter = true;
      item.index = index;
    });
    
    // Additional decorative objects (no hidden letter) to add variety.
    const decorativeObjects = [
      { type: "tree", left: 800, bottom: 180, rotation: 0, hasLetter: false },
      { type: "bush", left: 1000, bottom: 160, rotation: 10, hasLetter: false },
      { type: "house", left: 50, bottom: 200, rotation: -5, hasLetter: false }
    ];
    
    // Combine both arrays into one list of interactive items.
    const interactiveItems = secretLetters.concat(decorativeObjects);
    
    // Create the solution row – one slot per secret letter.
    const solutionContainer = document.getElementById("solution");
    secretLetters.forEach((item, index) => {
      const slot = document.createElement("div");
      slot.className = "slot";
      slot.setAttribute("data-index", index);
      solutionContainer.appendChild(slot);
    });
    
    // Create interactive objects and add them to the game container.
    const gameContainer = document.getElementById("game");
    interactiveItems.forEach(item => {
      // Create a container for this object (holds the object and, if applicable, the letter)
      const container = document.createElement("div");
      container.className = "interactive-container";
      container.style.left = item.left + "px";
      container.style.bottom = item.bottom + "px";
      
      // If the item hides a letter, create a letter element.
      if (item.hasLetter) {
        const letterElem = document.createElement("div");
        letterElem.className = "letter hidden";
        letterElem.innerText = item.letter;
        // Rotate the letter by the specified angle. (You can adjust further if desired.)
        letterElem.style.transform = "translateX(-50%) rotate(" + item.rotation + "deg)";
        container.appendChild(letterElem);
        item.letterElem = letterElem;
      }
      
      // Create the object element.
      const objElem = document.createElement("div");
      objElem.className = "object " + item.type;
      // Rotate the entire object for a natural, varied look.
      objElem.style.transform = "rotate(" + item.rotation + "deg)";
      container.appendChild(objElem);
      item.objElem = objElem;
      
      // For items with a hidden letter, add a click event to reveal the letter.
      if (item.hasLetter) {
        objElem.addEventListener("click", function(e) {
          if (objElem.classList.contains("removed")) return;
          objElem.classList.add("removed");
          if (item.letterElem) {
            item.letterElem.classList.remove("hidden");
            item.letterElem.classList.add("revealed");
          }
          // Update the corresponding solution slot.
          const slot = document.querySelector('.slot[data-index="' + item.index + '"]');
          if (slot) slot.innerText = item.letter;
          setTimeout(checkGameComplete, 600);
          e.stopPropagation();
        });
      }
      
      // Append the container to the game container.
      gameContainer.appendChild(container);
    });
    
    // Check if all letters have been revealed.
    function checkGameComplete() {
      const slots = document.querySelectorAll(".slot");
      let count = 0;
      slots.forEach(slot => {
        if (slot.innerText !== "") count++;
      });
      if (count === secretLetters.length) {
        setTimeout(() => {
          alert("Congratulations! You revealed the secret message!");
        }, 300);
      }
    }
  </script>
</body>
</html>
