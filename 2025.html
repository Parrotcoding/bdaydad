<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hidden Letters – Complex Scene</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background-color: #333;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow: hidden;
    }

    .instruction {
      margin: 10px;
      font-size: 20px;
      color: #fff;
    }

    .game-container {
      position: relative;
      width: 1200px;
      height: 800px;
      border: 2px solid #444;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
      overflow: hidden;
      background-color: #87CEEB; /* fallback */
    }

    /* Canvas is in the back */
    #background {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
    }

    /* Container for each letter object (positioned over the canvas) */
    .letter-object {
      position: absolute;
      width: 120px;
      height: 120px;
      z-index: 2;
      pointer-events: none; /* The clickable object inside will handle events */
    }

    /* The letter element (only its top portion initially visible) */
    .letter {
      position: absolute;
      bottom: 70px; /* so it “sticks out” above the object */
      left: 50%;
      transform: translateX(-50%);
      font-size: 48px;
      font-weight: bold;
      color: #fff;
      z-index: 1;
      pointer-events: none;
      transition: clip-path 0.5s;
    }

    /* Initially clip off most of the letter—only the top edge shows */
    .hidden-letter {
      clip-path: inset(0 0 35px 0);
    }

    /* When revealed, the full letter is visible */
    .revealed-letter {
      clip-path: none;
    }

    /* A more detailed house object */
    .object.house {
      position: absolute;
      bottom: 0;
      left: calc(50% - 40px);
      width: 80px;
      height: 60px;
      background: #D2691E;
      border: 2px solid #8B4513;
      border-radius: 4px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
      cursor: pointer;
      pointer-events: auto;
      transition: transform 0.6s ease, opacity 0.6s ease;
    }
    .object.house::before {
      content: "";
      position: absolute;
      bottom: 60px;
      left: 0;
      width: 0;
      height: 0;
      border-left: 40px solid transparent;
      border-right: 40px solid transparent;
      border-bottom: 30px solid #B22222;
    }

    /* A more detailed tree object */
    .object.tree {
      position: absolute;
      bottom: 0;
      left: calc(50% - 20px);
      width: 40px;
      height: 60px;
      background: #8B4513;
      border-radius: 2px;
      box-shadow: 1px 1px 3px rgba(0,0,0,0.5);
      cursor: pointer;
      pointer-events: auto;
      transition: transform 0.6s ease, opacity 0.6s ease;
    }
    .object.tree::after {
      content: "";
      position: absolute;
      bottom: 50px;
      left: -20px;
      width: 80px;
      height: 50px;
      background: #228B22;
      border-radius: 50%;
    }

    /* When an object is clicked, it animates away */
    .removed {
      transform: translateX(150px);
      opacity: 0;
    }

    /* The solution row at the bottom */
    #solution {
      width: 1200px;
      min-height: 80px;
      background: #222;
      color: #fff;
      font-size: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      letter-spacing: 8px;
      margin-top: 10px;
    }
    .slot {
      display: inline-block;
      width: 40px;
      height: 60px;
      border-bottom: 2px solid #fff;
      margin: 0 5px;
      text-align: center;
      line-height: 60px;
    }
  </style>
</head>
<body>
  <div class="instruction">
    Click on an object (house or tree) to reveal the hidden letter.
  </div>
  <div class="game-container" id="game">
    <!-- The canvas will render the complex scene -->
    <canvas id="background" width="1200" height="800"></canvas>
    <!-- Letter objects are created dynamically -->
  </div>
  <div id="solution">
    <!-- As letters are revealed, they populate these slots -->
  </div>

  <script>
    // Draw a complex, realistic scene on the canvas.
    function drawScene() {
      const canvas = document.getElementById('background');
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      // Sky gradient (top: blue, bottom: soft almond)
      const skyGradient = ctx.createLinearGradient(0, 0, 0, height);
      skyGradient.addColorStop(0, '#87CEEB');
      skyGradient.addColorStop(1, '#FFEBCD');
      ctx.fillStyle = skyGradient;
      ctx.fillRect(0, 0, width, height);
      
      // Sun with radial gradient
      const sunX = width * 0.8, sunY = height * 0.2, sunRadius = 50;
      const sunGradient = ctx.createRadialGradient(sunX, sunY, 10, sunX, sunY, sunRadius);
      sunGradient.addColorStop(0, '#FFD700');
      sunGradient.addColorStop(1, 'rgba(255,215,0,0)');
      ctx.fillStyle = sunGradient;
      ctx.beginPath();
      ctx.arc(sunX, sunY, sunRadius, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw some fluffy clouds
      function drawCloud(x, y, scale) {
        ctx.fillStyle = "rgba(255,255,255,0.8)";
        ctx.beginPath();
        ctx.arc(x, y, 20 * scale, Math.PI * 0.5, Math.PI * 1.5);
        ctx.arc(x + 25 * scale, y - 20 * scale, 20 * scale, Math.PI * 1, Math.PI * 1.85);
        ctx.arc(x + 55 * scale, y - 10 * scale, 25 * scale, Math.PI * 1.37, Math.PI * 1.91);
        ctx.arc(x + 70 * scale, y, 20 * scale, Math.PI * 1.5, Math.PI * 0.5);
        ctx.closePath();
        ctx.fill();
      }
      drawCloud(150, 100, 1);
      drawCloud(400, 80, 1.2);
      drawCloud(700, 120, 1);
      drawCloud(1000, 80, 0.8);
      
      // Draw mountains with snow caps
      function drawMountain(x, y, widthFactor, heightFactor, color, snowCap) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + 150 * widthFactor, y - 200 * heightFactor);
        ctx.lineTo(x + 300 * widthFactor, y);
        ctx.closePath();
        ctx.fill();
        if (snowCap) {
          ctx.fillStyle = "#FFF";
          ctx.beginPath();
          ctx.moveTo(x + 150 * widthFactor, y - 200 * heightFactor);
          ctx.lineTo(x + 130 * widthFactor, y - 150 * heightFactor);
          ctx.lineTo(x + 170 * widthFactor, y - 150 * heightFactor);
          ctx.closePath();
          ctx.fill();
        }
      }
      drawMountain(50, height * 0.8, 1, 1, "#696969", true);
      drawMountain(300, height * 0.8, 1, 1, "#808080", true);
      drawMountain(600, height * 0.8, 1, 1.2, "#505050", true);
      drawMountain(900, height * 0.8, 1, 1, "#7F7F7F", true);
      
      // Rolling green valley/hills at the bottom
      ctx.fillStyle = "#228B22";
      ctx.beginPath();
      ctx.moveTo(0, height * 0.8);
      ctx.quadraticCurveTo(width * 0.5, height * 0.7, width, height * 0.8);
      ctx.lineTo(width, height);
      ctx.lineTo(0, height);
      ctx.closePath();
      ctx.fill();
      
      // Draw a small village of houses in the valley
      function drawHouse(x, y, scale) {
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(x, y - 40 * scale, 50 * scale, 40 * scale);
        ctx.fillStyle = "#A52A2A";
        ctx.beginPath();
        ctx.moveTo(x, y - 40 * scale);
        ctx.lineTo(x + 25 * scale, y - 70 * scale);
        ctx.lineTo(x + 50 * scale, y - 40 * scale);
        ctx.closePath();
        ctx.fill();
      }
      drawHouse(200, height * 0.8, 1);
      drawHouse(280, height * 0.8, 1);
      drawHouse(360, height * 0.8, 1);
      drawHouse(450, height * 0.8, 1);
      drawHouse(550, height * 0.8, 1);
      
      // Draw a few trees along the valley
      function drawTree(x, y, scale) {
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(x, y - 30 * scale, 10 * scale, 30 * scale);
        ctx.fillStyle = "#006400";
        ctx.beginPath();
        ctx.arc(x + 5 * scale, y - 40 * scale, 15 * scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x - 5 * scale, y - 30 * scale, 15 * scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x + 15 * scale, y - 30 * scale, 15 * scale, 0, Math.PI * 2);
        ctx.fill();
      }
      drawTree(800, height * 0.8, 1);
      drawTree(850, height * 0.8, 1);
      drawTree(900, height * 0.8, 1);
    }
    drawScene();
    
    // Define the secret phrase letters and their fixed positions.
    // (Each object holds a letter and is placed using percentage values.)
    const letters = [
      { letter: "Y", left: "10%", top: "20%" },
      { letter: "O", left: "30%", top: "15%" },
      { letter: "U", left: "50%", top: "10%" },
      { letter: "R", left: "70%", top: "25%" },
      { letter: "E", left: "85%", top: "40%" },
      { letter: "T", left: "60%", top: "40%" },
      { letter: "H", left: "40%", top: "30%" },
      { letter: "E", left: "20%", top: "45%" },
      { letter: "B", left: "15%", top: "65%" },
      { letter: "E", left: "35%", top: "70%" },
      { letter: "S", left: "55%", top: "65%" },
      { letter: "T", left: "75%", top: "60%" },
      { letter: "D", left: "80%", top: "75%" },
      { letter: "A", left: "50%", top: "85%" },
      { letter: "D", left: "30%", top: "80%" },
      { letter: "E", left: "10%", top: "85%" },
      { letter: "V", left: "70%", top: "80%" },
      { letter: "E", left: "60%", top: "90%" },
      { letter: "R", left: "40%", top: "90%" }
    ];
    // For variety, assign the object type: house for even indexes, tree for odd indexes.
    letters.forEach((obj, i) => {
      obj.type = (i % 2 === 0) ? "house" : "tree";
    });
    
    const gameContainer = document.getElementById("game");
    const solutionContainer = document.getElementById("solution");
    
    // Create blank solution slots matching the phrase order.
    letters.forEach((item, index) => {
      const slot = document.createElement("div");
      slot.className = "slot";
      slot.setAttribute("data-index", index);
      solutionContainer.appendChild(slot);
    });
    
    // For each letter, create a container with the letter and an interactive scene object.
    letters.forEach((item, index) => {
      const container = document.createElement("div");
      container.className = "letter-object";
      container.style.left = item.left;
      container.style.top = item.top;
      container.setAttribute("data-index", index);
      
      // Create the letter element (initially only a bit visible)
      const letterElem = document.createElement("div");
      letterElem.className = "letter hidden-letter";
      letterElem.innerText = item.letter;
      container.appendChild(letterElem);
      
      // Create the scene object element (either house or tree)
      const objectElem = document.createElement("div");
      objectElem.className = "object " + item.type;
      objectElem.addEventListener("click", function(event) {
        if (objectElem.classList.contains("removed")) return;
        objectElem.classList.add("removed");
        letterElem.classList.remove("hidden-letter");
        letterElem.classList.add("revealed-letter");
        const slot = document.querySelector('.slot[data-index="' + index + '"]');
        slot.innerText = item.letter;
        setTimeout(checkGameComplete, 600);
      });
      container.appendChild(objectElem);
      gameContainer.appendChild(container);
    });
    
    function checkGameComplete() {
      const slots = document.querySelectorAll(".slot");
      let count = 0;
      slots.forEach(slot => {
        if (slot.innerText !== "") count++;
      });
      if (count === letters.length) {
        setTimeout(() => {
          alert("Congratulations! You revealed the message!");
        }, 300);
      }
    }
  </script>
</body>
</html>
