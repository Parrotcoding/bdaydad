<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Midground Platformer Game</title>
  <style>
    body { margin: 0; overflow: hidden; background: #87CEEB; }
    /* The canvas fills the window */
    #gameCanvas { display: block; }
    /* Secret message bar displayed at the bottom */
    #secretMessage {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 24px;
      color: #fff;
      text-shadow: 2px 2px #000;
      font-family: sans-serif;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <div id="secretMessage">Secret: _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _</div>

  <script>
    /************************************************
     *            GLOBAL VARIABLES & SETUP          *
     ************************************************/
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const secretMessageDiv = document.getElementById('secretMessage');

    // Define the overall world dimensions.
    const worldWidth = 3000;  // Map is now much wider.
    const GROUND_LEVEL = 500; // Y-coordinate for the ground (same for all objects).

    // Physics parameters.
    const GRAVITY = 0.5;
    const FRICTION = 0.8;
    const PLAYER_SPEED = 2;
    const JUMP_STRENGTH = -10;

    // The game can be in the normal world or inside a house.
    let gameState = {
      mode: 'world',         // 'world' or 'houseInterior'
      currentHouse: null     // holds a house object when entering an interior
    };

    // Camera offset for side‐scrolling.
    let cameraX = 0;

    // Store the letters as they’re collected; keys are orders (1–20)
    let collectedLetters = {};

    // The player is a simple rectangle.
    let player = {
      x: 50,
      y: GROUND_LEVEL - 40,
      width: 30,
      height: 40,
      vx: 0,
      vy: 0,
      climbing: false,
      onGround: false
    };

    // Keyboard input.
    let keys = {};
    window.addEventListener('keydown', (e) => {
      keys[e.key] = true;
      if (e.key === 'e' || e.key === 'E') {
        if (gameState.mode === 'world') {
          // Check if colliding with a house to enter its interior.
          let house = getCollidingHouse();
          if(house) {
            gameState.mode = 'houseInterior';
            gameState.currentHouse = house;
            // Reposition the player for interior view.
            player.x = canvas.width / 2;
            player.y = canvas.height - 100;
            player.vx = 0;
            player.vy = 0;
          }
        } else if (gameState.mode === 'houseInterior') {
          // Exit the house.
          gameState.mode = 'world';
          // Place the player near the house’s exterior.
          player.x = gameState.currentHouse.x + gameState.currentHouse.width + 10;
          player.y = gameState.currentHouse.y;
          gameState.currentHouse = null;
        }
      }
    });
    window.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    // Basic rectangle collision detection.
    function rectsIntersect(r1, r2) {
      return !(r2.x > r1.x + r1.width ||
               r2.x + r2.width < r1.x ||
               r2.y > r1.y + r1.height ||
               r2.y + r2.height < r1.y);
    }

    /************************************************
     *           WORLD OBJECTS (Interactive)        *
     *  (They now exist in two layers: foreground   *
     *   and midground. Both are on the same ground.) *
     ************************************************/

    // Foreground objects (closer to the player) – their coordinates are in world space.
    let objectsForeground = [
      // Houses (the letter is hidden until you enter)
      { type: 'house', x: 600, y: 350, width: 120, height: 120, letter: 'Y', order: 1, collected: false },
      { type: 'house', x: 1500, y: 350, width: 120, height: 120, letter: 'E', order: 5, collected: false },
      { type: 'house', x: 900, y: 350, width: 120, height: 120, letter: 'B', order: 9, collected: false },
      // Bushes
      { type: 'bush', x: 800, y: 400, width: 70, height: 40, letter: 'O', order: 2, collected: false },
      { type: 'bush', x: 1200, y: 500, width: 70, height: 40, letter: 'R', order: 4, collected: false },
      { type: 'bush', x: 1700, y: 480, width: 70, height: 40, letter: 'H', order: 7, collected: false },
      { type: 'bush', x: 2200, y: 500, width: 70, height: 40, letter: 'e', order: 10, collected: false },
      // Trees – drawn more realistically.
      { type: 'tree', x: 400, y: 200, width: 50, height: 150, letter: 'U', order: 3, collected: false },
      { type: 'tree', x: 700, y: 250, width: 50, height: 150, letter: 'T', order: 6, collected: false },
      { type: 'tree', x: 1000, y: 250, width: 50, height: 150, letter: 'E', order: 8, collected: false }
    ];

    // Midground objects (drawn behind the foreground).
    let objectsMidground = [
      // Houses
      { type: 'house', x: 1800, y: 300, width: 120, height: 120, letter: 'D', order: 13, collected: false },
      { type: 'house', x: 2500, y: 350, width: 120, height: 120, letter: 'E', order: 16, collected: false },
      { type: 'house', x: 2800, y: 300, width: 120, height: 120, letter: 'R', order: 19, collected: false },
      // Bushes
      { type: 'bush', x: 1300, y: 450, width: 70, height: 40, letter: 'T', order: 12, collected: false },
      { type: 'bush', x: 2100, y: 400, width: 70, height: 40, letter: 'D', order: 15, collected: false },
      { type: 'bush', x: 1600, y: 500, width: 70, height: 40, letter: 'E', order: 18, collected: false },
      // Trees (with realistic drawing)
      { type: 'tree', x: 1100, y: 250, width: 50, height: 150, letter: 'S', order: 11, collected: false },
      { type: 'tree', x: 900, y: 200, width: 50, height: 150, letter: 'V', order: 17, collected: false },
      { type: 'tree', x: 2400, y: 150, width: 50, height: 150, letter: '!', order: 20, collected: false },
      { type: 'tree', x: 2000, y: 200, width: 50, height: 150, letter: 'A', order: 14, collected: false }
    ];

    // For collision checks with interactive objects,
    // combine both layers.
    function getAllInteractiveObjects() {
      return objectsForeground.concat(objectsMidground);
    }

    // Returns the first house that the player is colliding with.
    function getCollidingHouse() {
      const objs = getAllInteractiveObjects();
      for(let obj of objs){
        if(obj.type === 'house'){
          let objRect = { x: obj.x, y: obj.y, width: obj.width, height: obj.height };
          let playerRect = { x: player.x, y: player.y, width: player.width, height: player.height };
          if(rectsIntersect(objRect, playerRect)){
            return obj;
          }
        }
      }
      return null;
    }

    /************************************************
     *                MAIN UPDATE LOOP              *
     ************************************************/
    function update() {
      if(gameState.mode === 'houseInterior'){
        updateInterior();
        drawInterior();
      } else {
        updateWorld();
        drawWorld();
      }
      updateSecretMessage();
      requestAnimationFrame(update);
    }

    /************************************************
     *             WORLD (GAME) MODE                *
     ************************************************/
    function updateWorld() {
      // Horizontal movement.
      if(keys['ArrowLeft'] || keys['a']){
        player.vx = -PLAYER_SPEED;
      } else if(keys['ArrowRight'] || keys['d']){
        player.vx = PLAYER_SPEED;
      } else {
        player.vx *= FRICTION;
      }

      // If the player presses up, check for climbing if near a tree.
      let collidingTree = getCollidingInteractiveObject('tree');
      if(keys['ArrowUp'] || keys['w']){
        if(collidingTree){
          player.climbing = true;
          player.vy = -PLAYER_SPEED; // climb upward
        } else if(player.onGround){
          player.vy = JUMP_STRENGTH;
          player.onGround = false;
        }
      } else {
        player.climbing = false;
      }

      // Apply gravity if not climbing.
      if(!player.climbing){
        player.vy += GRAVITY;
      }

      player.x += player.vx;
      player.y += player.vy;

      // Keep player within horizontal world boundaries.
      if(player.x < 0) player.x = 0;
      if(player.x + player.width > worldWidth) player.x = worldWidth - player.width;

      // Collision with the ground.
      if(player.y + player.height > GROUND_LEVEL){
        player.y = GROUND_LEVEL - player.height;
        player.vy = 0;
        player.onGround = true;
      } else {
        player.onGround = false;
      }

      // Check for collectible letters in trees and bushes:
      let allObjects = getAllInteractiveObjects();
      for(let obj of allObjects){
        // Only trees and bushes (houses reveal their letter inside).
        if((obj.type === 'tree' || obj.type === 'bush') && !obj.collected && obj.letter){
          // Define “hiding behind” as the player being above the object's midpoint.
          if((player.y + player.height/2) < (obj.y + obj.height/2)) {
            let objRect = { x: obj.x, y: obj.y, width: obj.width, height: obj.height };
            let playerRect = { x: player.x, y: player.y, width: player.width, height: player.height };
            if(rectsIntersect(objRect, playerRect)){
              obj.collected = true;
              collectedLetters[obj.order] = obj.letter;
            }
          }
        }
      }

      // Update camera: center on the player
      cameraX = player.x - canvas.width / 2;
      // Clamp cameraX so it doesn’t go past world boundaries.
      if(cameraX < 0) cameraX = 0;
      if(cameraX > worldWidth - canvas.width) cameraX = worldWidth - canvas.width;
    }

    // Utility: Return the first interactive object of a given type (from both layers) that the player is colliding with.
    function getCollidingInteractiveObject(type) {
      let objs = getAllInteractiveObjects();
      for(let obj of objs){
        if(obj.type === type){
          let rectObj = { x: obj.x, y: obj.y, width: obj.width, height: obj.height };
          let rectPlayer = { x: player.x, y: player.y, width: player.width, height: player.height };
          if(rectsIntersect(rectObj, rectPlayer)){
            return obj;
          }
        }
      }
      return null;
    }

    /************************************************
     *              DRAWING FUNCTIONS               *
     ************************************************/

    // Draw the whole world.
    function drawWorld() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw the sky.
      ctx.fillStyle = '#87CEEB';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw distant hills (optional decorative midground elements).
      drawHills();

      // Draw the ground (only what’s visible in the current camera view).
      ctx.fillStyle = '#654321';
      ctx.fillRect(0, GROUND_LEVEL, canvas.width, canvas.height - GROUND_LEVEL);

      // Draw midground objects first (they appear behind).
      for(let obj of objectsMidground){
        if(obj.type === 'tree'){
          drawTree(obj);
        } else if(obj.type === 'bush'){
          drawBush(obj);
        } else if(obj.type === 'house'){
          drawHouse(obj);
        }
      }

      // Then draw foreground objects.
      for(let obj of objectsForeground){
        if(obj.type === 'tree'){
          drawTree(obj);
        } else if(obj.type === 'bush'){
          drawBush(obj);
        } else if(obj.type === 'house'){
          drawHouse(obj);
        }
      }

      // Draw the player (adjusted for camera offset).
      ctx.fillStyle = '#FF0000';
      ctx.fillRect(player.x - cameraX, player.y, player.width, player.height);
    }

    // Optional: Draw some rolling hills in the distance.
    function drawHills() {
      ctx.fillStyle = '#228B22';
      ctx.beginPath();
      // Hills drawn relative to the world.
      // For simplicity, adjust the x coordinate by subtracting cameraX.
      ctx.arc(400 - cameraX, GROUND_LEVEL, 100, Math.PI, 2 * Math.PI);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(1200 - cameraX, GROUND_LEVEL, 150, Math.PI, 2 * Math.PI);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(2200 - cameraX, GROUND_LEVEL, 120, Math.PI, 2 * Math.PI);
      ctx.fill();
    }

    // Draw a tree with a trunk and multi‑circle foliage (more realistic style).
    function drawTree(tree) {
      // Determine opacity: if the player is “in front” (i.e. above the object’s midpoint),
      // make the tree semi‑transparent to reveal a hidden letter.
      let opacity = 1;
      if((player.y + player.height/2) < (tree.y + tree.height/2)) {
        opacity = 0.5;
      }
      ctx.save();
      ctx.globalAlpha = opacity;
      // Draw trunk (using a simple rectangle).
      ctx.fillStyle = '#8B4513';
      ctx.fillRect(tree.x + tree.width/2 - 5 - cameraX, tree.y + tree.height - 40, 10, 40);
      // Draw foliage using several overlapping circles.
      ctx.fillStyle = '#228B22';
      ctx.beginPath();
      ctx.arc(tree.x + tree.width/2 - cameraX, tree.y + tree.height - 50, 20, 0, Math.PI * 2);
      ctx.arc(tree.x + tree.width/2 - 20 - cameraX, tree.y + tree.height - 60, 15, 0, Math.PI * 2);
      ctx.arc(tree.x + tree.width/2 + 20 - cameraX, tree.y + tree.height - 60, 15, 0, Math.PI * 2);
      ctx.fill();
      // If the tree’s hidden letter hasn’t been collected and the tree is drawn transparent,
      // then show the letter.
      if(!tree.collected && tree.letter && opacity < 1){
        ctx.fillStyle = '#FFF';
        ctx.font = '20px sans-serif';
        ctx.fillText(tree.letter, tree.x + tree.width/2 - 10 - cameraX, tree.y + tree.height - 70);
      }
      ctx.restore();
    }

    // Draw a bush using overlapping arcs to simulate a natural clump.
    function drawBush(bush) {
      let opacity = 1;
      if((player.y + player.height/2) < (bush.y + bush.height/2)) {
        opacity = 0.5;
      }
      ctx.save();
      ctx.globalAlpha = opacity;
      ctx.fillStyle = '#006400';
      // Draw three overlapping circles.
      ctx.beginPath();
      ctx.arc(bush.x + bush.width * 0.35 - cameraX, bush.y + bush.height/2, bush.height/2, 0, Math.PI*2);
      ctx.arc(bush.x + bush.width * 0.65 - cameraX, bush.y + bush.height/2, bush.height/2, 0, Math.PI*2);
      ctx.arc(bush.x + bush.width * 0.5 - cameraX, bush.y - bush.height/4, bush.height/2, 0, Math.PI*2);
      ctx.fill();
      // Display the hidden letter if the bush is partly transparent.
      if(!bush.collected && bush.letter && opacity < 1){
        ctx.fillStyle = '#FFF';
        ctx.font = '20px sans-serif';
        // Place the letter roughly at the center of the bush.
        ctx.fillText(bush.letter, bush.x + bush.width/2 - 7 - cameraX, bush.y + bush.height/2 + 7);
      }
      ctx.restore();
    }

    // Draw a house.
    function drawHouse(house) {
      ctx.fillStyle = '#FFD700';
      ctx.fillRect(house.x - cameraX, house.y, house.width, house.height);
      // Draw a door for entering.
      ctx.fillStyle = '#654321';
      ctx.fillRect(house.x + house.width/2 - 10 - cameraX, house.y + house.height - 40, 20, 40);
      // (The house’s secret letter is revealed only on entering.)
    }

    /************************************************
     *              HOUSE INTERIOR MODE             *
     ************************************************/
    function updateInterior(){
      // Simple left/right movement inside the house without gravity.
      if(keys['ArrowLeft'] || keys['a']){
        player.vx = -PLAYER_SPEED;
      } else if(keys['ArrowRight'] || keys['d']){
        player.vx = PLAYER_SPEED;
      } else {
        player.vx = 0;
      }
      player.x += player.vx;
      if(player.x < 0) player.x = 0;
      if(player.x + player.width > canvas.width) player.x = canvas.width - player.width;

      // The collectible letter is drawn in a small rectangle at the top center.
      let houseLetter = gameState.currentHouse.letter;
      let houseOrder = gameState.currentHouse.order;
      let letterRect = { x: canvas.width/2 - 10, y: 50, width: 20, height: 20 };
      let playerRect = { x: player.x, y: player.y, width: player.width, height: player.height };
      if(!gameState.currentHouse.collected && rectsIntersect(letterRect, playerRect)){
        gameState.currentHouse.collected = true;
        collectedLetters[houseOrder] = houseLetter;
      }
    }

    function drawInterior(){
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Draw an interior background.
      ctx.fillStyle = '#F5DEB3';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      // Draw some basic furniture.
      ctx.fillStyle = '#8B4513';
      ctx.fillRect(100, canvas.height - 150, 100, 20);  // table
      ctx.fillRect(250, canvas.height - 120, 30, 30);   // chair
      // Draw a door for exit.
      ctx.fillStyle = '#654321';
      ctx.fillRect(canvas.width - 80, canvas.height - 150, 40, 70);
      // Reveal the hidden letter at the top center (if not collected).
      if(!gameState.currentHouse.collected){
        ctx.fillStyle = '#000';
        ctx.font = '30px sans-serif';
        ctx.fillText(gameState.currentHouse.letter, canvas.width/2 - 10, 70);
      }
      // Draw the player.
      ctx.fillStyle = '#FF0000';
      ctx.fillRect(player.x, player.y, player.width, player.height);
      // Hint to exit.
      ctx.fillStyle = '#000';
      ctx.font = '16px sans-serif';
      ctx.fillText("Press E near the door to exit", canvas.width - 220, canvas.height - 20);
    }

    /************************************************
     *              SECRET MESSAGE LOGIC            *
     ************************************************/
    function updateSecretMessage() {
      let message = '';
      for(let i = 1; i <= 20; i++){
        message += (collectedLetters[i] ? collectedLetters[i] : '_') + ' ';
      }
      secretMessageDiv.textContent = 'Secret: ' + message;
      if(Object.keys(collectedLetters).length === 20){
        secretMessageDiv.textContent += "  Congratulations! You've revealed the secret message!";
      }
    }

    // Start the game loop.
    update();
  </script>
</body>
</html>
